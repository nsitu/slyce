This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-26T01:38:12.941Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/workflows/main.yml
.gitignore
captain-definition
Dockerfile
index.html
package.json
postcss.config.js
README.md
src/App.vue
src/components/ActivityLog.vue
src/components/DownloadArea.vue
src/components/ExplanatoryMessages.vue
src/components/FileInfo.vue
src/components/Footer.vue
src/components/Header.vue
src/components/ScaleMessage.vue
src/components/SettingsArea.vue
src/components/SkipMessage.vue
src/components/StatusBox.vue
src/components/Tile.vue
src/components/UploadArea.vue
src/components/VideoPlayer.vue
src/composables/useNiceFormat.js
src/composables/useTilePlan.js
src/composables/useTilePlan.md
src/main.js
src/modules/blobDownloader.js
src/modules/canvasPool.js
src/modules/dragAndDropHandler.js
src/modules/frameProcessor.js
src/modules/iconLoader.js
src/modules/metaDataExtractor.js
src/modules/resourceMonitor.js
src/modules/videoDecoder.js
src/modules/videoEncoder.js
src/modules/videoProcessor.js
src/modules/webDemuxer.js
src/stores/appStore.js
tailwind.config.js
vite.config.mjs

================================================================
Repository Files
================================================================

================
File: .github/workflows/main.yml
================
name: Deploy to Caprover
on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest 

    steps:
      - uses: actions/checkout@v4 
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies  # see also, package.json
        run: npm install

      - name: Build with Vite
        run: npm run build    # i.e. "vite build"

      - name: Include Dockerfile and CapRover configuration
        run: cp Dockerfile dist/ && cp captain-definition dist/

      # Make a tarball of the dist/ folder for deployment
      # and also include the Dockerfile and CapRover configuration
      - uses: a7ul/tar-action@v1.2.0
        with:
          command: c      # "c" means "create" (new tarball)
          cwd: "./dist"  
          files: |
            ./ 
          outPath: deploy.tar
      # Deploy the tarball to CapRover, using the CapRover GitHub Action
      # Make sure you add CapRover Secrets to Repository Settings 
      # i.e. Secrets and Variables > Actions > Repository Secrets
      # SERVER: e.g. https://captain.example.com 
      # APP: the name of the app in CapRover (e.g. "my-app")
      # TOKEN: generated in CapRover under "Deployment" 
      - name: Deploy App to Caprover
        uses: caprover/deploy-from-github@v1.1.2
        with:
          server: '${{ secrets.SERVER }}'
          app: '${{ secrets.APP }}'
          token: '${{ secrets.TOKEN }}'

================
File: .gitignore
================
node_modules
dist

================
File: captain-definition
================
{  
    "schemaVersion": 2,  
    "dockerfilePath" :"./Dockerfile"
}

================
File: Dockerfile
================
FROM nginx:alpine
COPY . /usr/share/nginx/html

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebCodecsTest</title>
    <link
        rel="icon"
        href="ffmpeg.svg"
        type="image/svg+xml"
    >
    <link
        href="style.css"
        rel="stylesheet"
    />


</head>

<body>

    <div id="app"></div>

    <script
        type="module"
        src="/src/main.js"
    ></script>
</body>

</html>

================
File: package.json
================
{
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "@primevue/themes": "^4.0.7",
        "@vitejs/plugin-vue": "^5.1.4",
        "@vueuse/core": "^11.1.0",
        "canvas-size": "^2.0.0",
        "mp4-muxer": "^5.1.3",
        "pinia": "^2.2.4",
        "primevue": "^4.0.7",
        "vite": "^5.4.8",
        "vite-plugin-static-copy": "^1.0.6",
        "vue": "^3.5.11",
        "web-demuxer": "^2.2.0",
        "webm-muxer": "^5.0.2",
        "workerpool": "^9.2.0"
    },
    "devDependencies": {
        "autoprefixer": "^10.4.20",
        "postcss": "^8.4.47",
        "tailwindcss": "^3.4.13",
        "vite-plugin-vue-devtools": "^7.4.6"
    }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: README.md
================
# Testing Web Codecs
This demo creates an artistic cross section of a video using WebCodecs, WebDemuxer, and Canvas. One row of pixels is sampled from each frame. Canvas dimensions are set based on frame count. Live Demo: [https://web-codecs-test.haroldsikkema.com/](https://web-codecs-test.haroldsikkema.com/)

# Development
The project uses Vite as a build tool. During development, use `npm run dev` to launch the Vite server. 

# Deployment
This project includes a GitHub action that builds the frontend and deploys it to CapRover. 

# TODO 
- Test the accuracy of framecount supplied by web-demuxer. For linear sampling patterns the exact framecount is less important, but Sine wave sampling is going to require more accuracy. Account for framecount discrepancies, perhaps via a test run.

- Account for videos that are taller than they are wide. while most portrait videos are 1920x1080 with a rotation metadata. sometimes you do get 1080x1920 videos e.g. when processed Adobe Premiere by SVP Smooth Video Project

- Allow for manual control of rotation.

- Allow for the use of a webcam as a source

- split outputs into a series of square videos instead of a single long video.

- Account for a wide range of factors, including orientation, rotation, sampling mode (rows or columns), write mode (rows or columns), use of short side, etc.

- Test whether output should always be columns, so as to establish a standardfor threejs work later on

================
File: src/App.vue
================
<script setup>

    import { useAppStore } from './stores/appStore';
    const app = useAppStore()  // Pinia store

    import { onMounted } from 'vue';
    import { dragAndDrop } from './modules/dragAndDropHandler';

    import Header from './components/Header.vue'
    import Footer from './components/Footer.vue'
    import UploadArea from './components/UploadArea.vue';
    import ActivityLog from './components/ActivityLog.vue';
    import StatusBox from './components/StatusBox.vue';
    import SettingsArea from './components/SettingsArea.vue';
    import DownloadArea from './components/DownloadArea.vue';


    import Tabs from 'primevue/tabs';
    import TabList from 'primevue/tablist';
    import Tab from 'primevue/tab';
    import TabPanels from 'primevue/tabpanels';
    import TabPanel from 'primevue/tabpanel';


    onMounted(() => {
        dragAndDrop((file) => {
            app.set('file', file)
            app.set('fileURL', URL.createObjectURL(file))
            app.set('currentTab', '1')
        });
    });

</script>

<template>
    <main>

        <Header></Header>

        <Tabs v-model:value="app.currentTab">
            <TabList>
                <Tab value="0">Start</Tab>
                <Tab value="1">Settings</Tab>
                <Tab value="2">Process</Tab>
                <Tab value="3">Output</Tab>
            </TabList>
            <TabPanels>
                <TabPanel value="0">
                    <UploadArea></UploadArea>
                </TabPanel>
                <TabPanel value="1">
                    <SettingsArea></SettingsArea>
                </TabPanel>
                <TabPanel value="2">
                    <ActivityLog></ActivityLog>
                    <StatusBox></StatusBox>
                </TabPanel>
                <TabPanel value="3">
                    <DownloadArea></DownloadArea>
                </TabPanel>
            </TabPanels>
        </Tabs>
        <Footer></Footer>


    </main>


</template>

<style>
    main {
        font-family: Avenir, Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-align: center;
        color: #2c3e50;
        min-height: 100vh;
    }

</style>

================
File: src/components/ActivityLog.vue
================
<script setup>

    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

</script>
<template>
    <div
        id="activity-log"
        v-if="app.messages.length > 0"
    >
        <p v-for="message in app.messages">{{ message }}</p>
    </div>
</template>
<style scoped>

    #activity-log {
        max-height: 15rem;
        overflow-y: scroll;
        padding: 1rem;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
    }
</style>

================
File: src/components/DownloadArea.vue
================
<template>
    <h3>Results</h3>
    <div
        class="flex items-center gap-2 video-player-container"
        v-for="(blob, tileNumber) in app.blobs"
        :key="tileNumber"
    >
        <VideoPlayer
            :url="blob.url"
            :playbackTime="app.currentPlaybackTime"
            :isPlaying="app.isPlaying"
            :isPrimary="tileNumber === '0'"
            @playback-state-change="handlePlaybackStateChange"
        />
        <button
            class="bg-blue-500 text-white px-4 py-2 rounded-md"
            @click="downloadBlob(blob.url)"
        >
            Download
        </button>
    </div>
</template>

<script setup>
    import { downloadBlob } from '../modules/blobDownloader.js';
    import { useAppStore } from '../stores/appStore';
    import VideoPlayer from './VideoPlayer.vue';

    const app = useAppStore();

    // Handle playback state changes from the first/primary video
    function handlePlaybackStateChange({ currentTime, playing }) {
        app.updatePlaybackState({ currentTime, playing });
    }

</script>

<style scoped>
    .video-player-container {
        width: 20rem;
        margin-bottom: 0.1rem;
    }

</style>

================
File: src/components/ExplanatoryMessages.vue
================
<script setup>

    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

    const { plan } = defineProps({
        plan: Object
    })


    import Panel from 'primevue/panel';
    import Accordion from 'primevue/accordion';
    import AccordionPanel from 'primevue/accordionpanel';
    import AccordionHeader from 'primevue/accordionheader';
    import AccordionContent from 'primevue/accordioncontent';


</script>
<template>

    <Panel
        v-if="plan.rotate !== 0 || plan.skipping || plan.isScaled || plan.notices"
        style="background: #eee;"
        class="w-full"
    >
        <template #header>
            <div class="flex items-center gap-2">
                <span class="material-symbols-outlined">info</span>
                <span class="font-bold">Tile Plan</span>
            </div>
        </template>
        <Accordion
            class="w-full"
            multiple
        >
            <AccordionPanel
                value="0"
                v-if="plan.rotate !== 0"
            >
                <AccordionHeader>
                    <div class="flex items-center gap-1 cursor-default">
                        <span class="material-symbols-outlined">rotate_90_degrees_cw</span>
                        <span> Rotating samples by</span>
                        <span> {{ plan.rotate }}°</span>
                    </div>
                </AccordionHeader>
                <AccordionContent>
                    <p class="m-0 text-left	">
                        Sampled {{ app.samplingMode }} will be joined as {{ app.outputMode }}.
                    </p>
                </AccordionContent>
            </AccordionPanel>
            <AccordionPanel
                value="1"
                v-if="plan.skipping"
            >
                <AccordionHeader>
                    <div class="flex items-center gap-1 cursor-default">
                        <span class="material-symbols-outlined">step_over</span>
                        <span>Skipping</span>
                        <span> {{ plan.skipping }} frames</span>
                    </div>
                </AccordionHeader>
                <AccordionContent>
                    <p class="m-0 text-left">
                        {{ plan.length }} {{ app.tileProportion }} {{ plan.length == 1 ? 'tile' : 'tiles' }} at full
                        resolution
                        ({{ plan.width }}x{{ plan.height }}) {{ plan.length == 1 ? 'takes' : 'take' }} up {{
                            app.frameCount -
                            plan.skipping }} of {{
                            app.frameCount }}
                        possible sample {{ app.samplingMode }}. {{ plan.skipping }} {{ app.samplingMode }} from frames
                        {{ app.frameCount - plan.skipping + 1 }}-{{ app.frameCount }} do not form a full tile and will
                        be
                        skipped.
                    </p>
                </AccordionContent>
            </AccordionPanel>
            <AccordionPanel
                value="2"
                v-if="plan.isScaled"
            >
                <AccordionHeader>
                    <div
                        v-if="(plan.scaleTo !== plan.scaleFrom)"
                        class="flex items-center gap-1 cursor-default"
                    >
                        <span
                            v-if="(plan.scaleTo < plan.scaleFrom)"
                            class="material-symbols-outlined"
                        >close_fullscreen</span>
                        <span v-if="(plan.scaleTo < plan.scaleFrom)">Scaling down from</span>
                        <span
                            v-if="(plan.scaleTo > plan.scaleFrom)"
                            class="material-symbols-outlined"
                        >open_in_full</span>
                        <span v-if="(plan.scaleTo > plan.scaleFrom)">Scaling up from</span>
                        <span> {{ plan.scaleFrom }}<span style="font-variant: small-caps;">px</span></span>

                        <span>to</span>
                        <span> {{ plan.scaleTo }}<span style="font-variant: small-caps;">px</span></span>

                    </div>
                </AccordionHeader>
                <AccordionContent>
                    <p class="m-0 text-left">
                        {{ app.frameCount }} sampled {{ app.samplingMode }} are sufficient for {{ plan.length }} {{
                            plan.length ==
                                1 ? 'tile' : 'tiles' }} of {{ plan.scaleTo }}px. Downsampling from {{ plan.scaleFrom }}px to
                        retain
                        proportions.
                    </p>
                </AccordionContent>
            </AccordionPanel>

            <AccordionPanel
                value="3"
                v-if="plan.length == 0"
            >
                <AccordionHeader>
                    <div class="flex items-center gap-1 cursor-default">
                        <span class="material-symbols-outlined">warning</span>
                        <span>Insufficient frames</span>
                    </div>
                </AccordionHeader>
                <AccordionContent>
                    <p class="m-0 text-left">
                        {{ app.frameCount }} sampled {{ app.samplingMode }} is not adequate to fill a tile.
                    </p>
                </AccordionContent>
            </AccordionPanel>

            <AccordionPanel
                value="4"
                v-if="plan.notices?.length > 0"
            >
                <AccordionHeader>
                    <div class="flex items-center gap-1 cursor-default">
                        <span class="material-symbols-outlined">warning</span>
                        <span>Notices</span>
                    </div>
                </AccordionHeader>
                <AccordionContent>
                    <p
                        class="m-0 text-left"
                        v-for="notice in plan.notices"
                    >
                        {{ notice }}
                    </p>
                </AccordionContent>
            </AccordionPanel>

            <!-- if (plan.length == 0) {
                // if the calculated number of tiles is zero
                // we lack sufficient frames to fill the last tile
                plan.notices.push('Not enough frames to fill a tile')
            } -->


        </Accordion>
    </Panel>
</template>

<style scoped>
    .small-icon {
        font-size: 1.125rem;
    }
</style>

================
File: src/components/FileInfo.vue
================
<script setup>

    // This component embeds a preview of the uploaded video file
    // it also displays metadata about the video 
    // It assumes that the relevant data has been added to the store
    // app.fileURL  a blob URL for the uploaded video file
    // app.fileInfo  an object with metadata about the video file

    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store  

    import { useNiceFormat } from '../composables/useNiceFormat';
    const { niceCodec, niceDuration, niceFrameRate, niceBitRate } = useNiceFormat();

    import VideoPlayer from './VideoPlayer.vue';

</script>

<template>
    <div
        class="flex flex-col items-start gap-2"
        v-if="app?.fileInfo?.name"
    >
        <div class="smallPlayer">
            <VideoPlayer
                v-if="app.fileURL"
                :url="app.fileURL"
            ></VideoPlayer>
        </div>
        <table>
            <tbody>
                <tr>
                    <td class="file-info-label">File Name <span class="material-symbols-outlined">
                            video_file
                        </span></td>
                    <td class="file-info-value">{{ app.fileInfo?.name }}</td>
                </tr>

                <tr>
                    <td class="file-info-label">Codec <span class="material-symbols-outlined">
                            frame_source
                        </span></td>
                    <td class="file-info-value">{{ niceCodec(app.fileInfo?.codec_string) }}</td>
                </tr>
                <tr>
                    <td class="file-info-label">Codec String <span class="material-symbols-outlined">
                            barcode
                        </span></td>
                    <td class="file-info-value">{{ app.fileInfo?.codec_string }}</td>
                </tr>
                <tr>
                    <td class="file-info-label">Duration <span class="material-symbols-outlined">
                            timer
                        </span></td>
                    <td class="file-info-value">{{ niceDuration(app.fileInfo?.duration) }}</td>
                </tr>
                <tr>
                    <td class="file-info-label">Frame Rate <span class="material-symbols-outlined">
                            speed
                        </span></td>
                    <td class="file-info-value">{{ niceFrameRate(app.fileInfo?.r_frame_rate) }}</td>
                </tr>
                <tr>
                    <td class="file-info-label">Frame Count <span class="material-symbols-outlined">
                            calculate
                        </span></td>
                    <td class="file-info-value">{{ app.fileInfo?.nb_frames }}</td>
                </tr>
                <tr>
                    <td class="file-info-label">Resolution <span class="material-symbols-outlined">
                            view_compact
                        </span></td>
                    <td class="file-info-value">{{ app.fileInfo?.width }} x {{ app.fileInfo?.height }} pixels(w x h)
                    </td>
                </tr>
                <tr>
                    <td class="file-info-label"> Rotation <span class="material-symbols-outlined">
                            rotate_right
                        </span></td>
                    <td class="file-info-value"> {{ app.fileInfo?.rotation }} degrees </td>
                </tr>
                <tr>
                    <td class="file-info-label"> Bit Rate <span class="material-symbols-outlined">
                            equalizer
                        </span></td>
                    <td class="file-info-value">{{ niceBitRate(app.fileInfo?.bit_rate) }}</td>
                </tr>
            </tbody>
        </table>
    </div>
    <div v-else>
        Loading...
    </div>
</template>
<style scoped>

    .smallPlayer {
        max-width: 20vw;
    }

    #file-info table {
        background-color: #eee;
    }

    #file-info tr {
        border-bottom: 1px solid #fff;
    }


    .file-info-label {
        display: flex;
        align-items: center;
        justify-content: end;
        gap: 0.5rem;
        padding: 0 0 0 0.5rem;
    }

    .file-info-value {
        text-align: left;
        padding-left: 0rem;
        padding: 0 0.5rem;
    }
</style>

================
File: src/components/Footer.vue
================
<template>
    <!-- Header -->
    <div class="flex gap-5 items-center justify-center p-4">
        <p class="text-sm">This demo animates artistic
            <a
                target="_blank"
                href="https://en.wikipedia.org/wiki/Slit-scan_photography"
            >
                cross sections of a video
            </a> using
            <a
                target="_blank"
                href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API"
            >
                WebCodecs</a>,
            <a
                target="_blank"
                href="https://github.com/ForeverSc/web-demuxer"
            >
                WebDemuxer</a>, and
            <a
                target="_blank"
                href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API"
            >
                Canvas</a>. Multiple cross sections are made from the video. Each cross section samples one row of
            pixels
            from each frame at
            a given location. Cross sections are animated into a new video which amounts to a strategic swap of the time
            and
            space dimensions. The strategic bit allows for a loopable back-and-forth sway.
        </p>
    </div>
</template>

================
File: src/components/Header.vue
================
<template>
    <!-- Header -->
    <div class="flex gap-3 items-center justify-center p-4 w-full">
        <img src="/slice-logo.png" />
        <svg viewBox="0 0 1316 570">
            <path
                fill-rule="evenodd"
                d="M1258.955,295.797 C1223.101,312.094 1171.556,321.150 1104.390,322.994 C1106.926,334.720 1112.652,344.338 1121.597,351.826 C1133.889,362.118 1150.898,367.263 1172.624,367.263 C1186.345,367.263 1201.018,365.168 1216.647,360.974 C1232.271,356.784 1247.328,350.875 1261.814,343.250 L1281.538,411.001 C1263.431,421.676 1244.090,429.296 1223.508,433.870 C1202.925,438.444 1183.201,440.731 1164.334,440.731 C1122.405,440.731 1089.673,429.917 1066.139,408.285 C1042.599,386.657 1030.834,356.592 1030.834,318.094 C1030.834,279.601 1038.553,246.012 1053.989,217.327 C1069.426,188.646 1091.009,166.300 1118.738,150.291 C1146.467,134.283 1178.814,126.278 1215.789,126.278 C1247.043,126.278 1271.484,134.095 1289.114,149.719 C1306.739,165.348 1315.556,187.074 1315.556,214.897 C1315.556,251.680 1296.689,278.645 1258.955,295.797 ZM1229.511,203.462 C1223.030,199.272 1213.882,197.173 1202.068,197.173 C1182.437,197.173 1165.191,201.845 1150.326,211.181 C1135.461,220.520 1123.884,233.576 1115.593,250.344 C1112.794,256.008 1110.467,261.995 1108.591,268.289 C1145.570,266.751 1175.301,262.532 1197.780,255.633 C1225.411,247.155 1239.230,235.577 1239.230,220.900 C1239.230,213.467 1235.988,207.656 1229.511,203.462 ZM965.874,207.321 C954.247,202.274 940.240,199.746 923.852,199.746 C904.985,199.746 888.547,204.177 874.540,213.039 C860.533,221.901 849.670,234.291 841.951,250.201 C834.233,266.116 830.276,284.746 830.088,306.088 C830.276,325.527 836.234,340.584 847.955,351.255 C859.675,361.930 876.112,367.263 897.266,367.263 C914.418,367.263 931.235,364.597 947.722,359.259 C964.204,353.926 978.832,346.873 991.602,338.105 L1020.760,400.995 C1002.845,413.002 982.405,422.627 959.442,429.868 C936.475,437.108 912.989,440.731 888.976,440.731 C845.141,440.731 811.172,430.011 787.065,408.571 C762.954,387.131 750.903,356.972 750.903,318.094 C750.903,279.409 758.380,245.726 773.344,217.041 C788.302,188.360 809.363,166.063 836.520,150.148 C863.677,134.238 895.453,126.278 931.856,126.278 C960.251,126.278 983.835,130.566 1002.608,139.142 C1021.377,147.718 1037.242,161.538 1050.204,180.593 L997.319,231.763 C987.980,220.520 977.496,212.373 965.874,207.321 ZM602.339,471.890 C557.838,510.955 503.572,543.642 439.538,569.942 L405.234,502.764 C449.445,485.227 487.894,464.980 520.581,442.017 C538.380,429.511 554.741,415.965 569.686,401.395 C549.722,369.545 531.206,333.450 514.149,293.081 C494.139,245.726 475.651,192.028 458.691,131.996 L537.876,126.278 C559.460,215.218 586.766,286.741 619.785,340.881 C635.943,316.527 649.717,289.784 661.084,260.635 C675.949,222.521 687.670,179.642 696.246,131.996 L775.430,131.996 C760.945,208.036 739.599,273.928 711.397,329.672 C683.190,385.416 646.836,432.825 602.339,471.890 ZM404.834,259.206 C399.304,279.601 395.637,295.131 393.828,305.802 C392.015,316.477 391.113,324.004 391.113,328.385 C390.728,354.305 408.358,367.263 443.998,367.263 C454.476,367.263 463.722,366.075 471.727,363.690 C479.731,361.309 489.258,357.258 500.313,351.541 L520.038,419.577 C506.696,425.486 492.640,430.489 477.873,434.585 C463.102,438.680 446.186,440.731 427.132,440.731 C389.013,440.731 360.284,432.110 340.943,414.860 C321.598,397.614 311.928,371.649 311.928,336.961 C311.928,330.864 312.830,321.811 314.644,309.804 C316.453,297.798 320.312,280.932 326.221,259.206 L364.241,118.560 C368.051,104.079 367.100,93.024 361.383,85.400 C355.665,77.780 346.518,73.965 333.939,73.965 C324.792,73.965 315.595,74.492 306.353,75.537 C297.107,76.587 287.915,78.253 278.767,80.540 L267.047,8.502 C281.148,5.264 295.249,3.120 309.355,2.070 C323.456,1.025 337.557,0.498 351.663,0.498 C390.349,0.498 417.935,10.503 434.421,30.513 C450.903,50.524 453.811,79.874 443.140,118.560 L404.834,259.206 ZM287.801,203.748 C271.980,202.417 257.642,201.416 244.778,200.746 C231.914,200.081 220.430,199.746 210.331,199.746 C180.409,199.746 158.062,201.988 143.296,206.464 C128.525,210.944 121.141,217.755 121.141,226.903 C121.141,229.762 122.378,232.098 124.857,233.907 C127.332,235.720 130.861,237.293 135.434,238.624 L216.049,262.065 C237.962,268.546 254.448,277.693 265.503,289.508 C276.554,301.327 282.084,316.093 282.084,333.817 C282.084,369.456 267.549,396.185 238.489,414.002 C209.424,431.824 165.638,440.731 107.134,440.731 C84.644,440.731 64.491,440.016 46.673,438.587 C28.851,437.157 13.370,435.013 0.220,432.155 L22.517,358.116 C46.910,361.166 67.206,363.453 83.407,364.976 C99.603,366.504 111.801,367.263 119.998,367.263 C146.105,367.263 165.593,364.932 178.457,360.260 C191.321,355.592 197.753,348.588 197.753,339.248 C197.753,336.202 196.467,333.772 193.894,331.959 C191.321,330.150 187.650,328.578 182.888,327.242 L77.975,295.225 C64.634,291.223 54.771,284.505 48.388,275.072 C42.001,265.638 38.812,253.967 38.812,240.053 C38.812,201.939 54.293,173.446 85.265,154.579 C116.232,135.712 162.779,126.278 224.910,126.278 C237.676,126.278 251.018,126.756 264.932,127.708 C278.841,128.664 293.420,130.093 308.669,131.996 L287.801,203.748 Z"
            />
        </svg>
        <div class="separator"></div>
        <p>Video Processing Toolkit</p>
    </div>
</template>
<style scoped>
    img {
        max-width: 7rem;
        margin-bottom: 0.75rem;
    }


    .separator {
        width: 3px;
        height: 4rem;
        background: #ddd;
        padding: 0px;
        margin: 0 2rem;
    }

    svg {
        width: 8rem;
    }

    svg path {
        fill: #434242;
    }
</style>

================
File: src/components/ScaleMessage.vue
================
<script setup>


    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

    const { plan } = defineProps({
        plan: Object
    })

</script>
<template>
    <div
        v-if="(plan.scaleTo !== plan.scaleFrom)"
        class="flex items-center gap-1 cursor-default"
        v-tooltip.left="`${app.frameCount} sampled ${app.samplingMode} are sufficient for ${plan.length} ${plan.length == 1 ? 'tile' : 'tiles'} of ${plan.scaleTo}px. Downsampling from ${plan.scaleFrom}px to retain proportions.`"
    >
        <span
            v-if="(plan.scaleTo < plan.scaleFrom)"
            class="material-symbols-outlined"
        >close_fullscreen</span>
        <span v-if="(plan.scaleTo < plan.scaleFrom)">Scaling down from</span>
        <span
            v-if="(plan.scaleTo > plan.scaleFrom)"
            class="material-symbols-outlined"
        >open_in_full</span>
        <span v-if="(plan.scaleTo > plan.scaleFrom)">Scaling up from</span>
        <span> {{ plan.scaleFrom }}<span style="font-variant: small-caps;">px</span></span>

        <span>to</span>
        <span> {{ plan.scaleTo }}<span style="font-variant: small-caps;">px</span></span>

    </div>
</template>
<style scoped></style>

================
File: src/components/SettingsArea.vue
================
<script setup>

    import { watch, watchEffect, ref, onMounted, computed } from 'vue';
    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

    import { useTilePlan } from '../composables/useTilePlan';
    const { tilePlan } = useTilePlan();

    import { getMetaData } from '../modules/metaDataExtractor';
    import { processVideo } from '../modules/videoProcessor';

    import Tile from './Tile.vue';
    // import SkipMessage from './SkipMessage.vue';
    // import ScaleMessage from './ScaleMessage.vue'; 
    import ExplanatoryMessages from './ExplanatoryMessages.vue';


    // when a file is uploaded get the metadata
    watch(() => app.file, () => getMetaData())

    import FileInfo from './FileInfo.vue';
    import Select from 'primevue/select';
    import InputText from 'primevue/inputtext';
    import InputNumber from 'primevue/inputnumber';





    // Watch for changes in samplingMode and adjust samplePixelCount accordingly
    watchEffect(() => {
        if (app.fileInfo?.height && app.fileInfo?.width) {
            if (app.samplingMode == 'columns') {
                app.samplePixelCount = app.fileInfo?.height
            }
            if (app.samplingMode == 'rows') {
                app.samplePixelCount = app.fileInfo?.width
            }
        }
    });



    import RadioButton from 'primevue/radiobutton';






</script>
<template>

    <div class="flex  items-start gap-5">
        <FileInfo v-if="app.file"></FileInfo>

        <div
            id="settings"
            class="flex flex-col gap-3 items-start"
        >
            <h3 class="text-xl">Cross Sections</h3>
            <p>Choose a sampling strategy:</p>


            <div class="flex w-full gap-6">
                <label
                    style="max-width: 15rem;"
                    class="flex flex-col grow items-start gap-2"
                    for="plane"
                    :class="(app.crossSectionType === 'plane') ? 'activeLabel' : ''"
                >

                    <div class="flex items-center gap-2 w-full">
                        <RadioButton
                            v-model="app.crossSectionType"
                            inputId="plane"
                            name="crossSectionType"
                            value="plane"
                        />
                        <span>Planes</span>
                        <svg
                            class="ml-auto"
                            xmlns="http://www.w3.org/2000/svg"
                            version="1.1"
                            viewBox="0 0 100 30"
                        >
                            <line
                                x1="0"
                                y1="2.3"
                                x2="100"
                                y2="2.3"
                            />
                            <line
                                x1="0"
                                y1="5.1"
                                x2="100"
                                y2="5.1"
                            />
                            <line
                                x1="0"
                                y1="20.7"
                                x2="100"
                                y2="20.7"
                            />
                            <line
                                x1="0"
                                y1="15"
                                x2="100"
                                y2="15"
                            />
                            <line
                                x1="0"
                                y1="27.7"
                                x2="100"
                                y2="27.7"
                            />
                            <line
                                x1="0"
                                y1="24.9"
                                x2="100"
                                y2="24.9"
                            />
                            <line
                                x1="0"
                                y1="9.3"
                                x2="100"
                                y2="9.3"
                            />
                        </svg>
                    </div>
                    <small>Sample pixels via an eased distribution of planes</small>
                </label>
                <label
                    class="flex flex-col grow items-start gap-2"
                    style="max-width: 15rem;"
                    for="corrugated"
                    :class="(app.crossSectionType === 'corrugated') ? 'activeLabel' : ''"
                >
                    <div class="flex items-center gap-2 w-full">
                        <RadioButton
                            v-model="app.crossSectionType"
                            inputId="corrugated"
                            name="crossSectionType"
                            value="corrugated"
                        />

                        <span>Waves</span>
                        <svg
                            viewBox="0 0 100 30"
                            class="ml-auto"
                        >
                            <path
                                d="M0,0c9.1,0,17.1,7.5,25,15,8,7.5,15.9,15,25,15s17.1-7.5,25-15c8-7.5,15.9-15,25-15" />
                            <path d="M0,15c7.9,7.5,15.9,15,25,15s17.1-7.5,25-15C58,7.5,65.9,0,75,0s17.1,7.5,25,15" />
                            <path
                                d="M0,30c9.1,0,17.1-7.5,25-15C33,7.5,40.9,0,50,0s17.1,7.5,25,15c8,7.5,15.9,15,25,15" />
                            <path d="M0,15C8,7.5,15.9,0,25,0s17.1,7.5,25,15c8,7.5,15.9,15,25,15s17.1-7.5,25-15" />
                        </svg>
                    </div>
                    <small>Sample pixels via evenly distributed corrugated forms</small>
                </label>
            </div>

            <h3 class="text-xl">Sampling Configuration</h3>

            <div class="flex gap-2 justify-start items-center">

                <span>From each frame, sample</span>
                <InputNumber
                    v-model="app.crossSectionCount"
                    placeholder="60"
                    :min="1"
                    :max="240"
                >
                </InputNumber>
                <Select
                    v-model="app.samplingMode"
                    :options="['columns', 'rows']"
                />

                <span>of</span>
                <span
                    v-if="app.fileInfo?.width && app.samplingMode == 'rows'"
                    class="sample-pixel-count"
                >
                    {{ app.fileInfo.width }} pixels</span>
                <span
                    v-if="app.fileInfo?.height && app.samplingMode == 'columns'"
                    class="sample-pixel-count"
                >
                    {{ app.fileInfo.height }} pixels</span>

            </div>


            <h3 class="text-xl">Output and Rendering</h3>

            <div class="flex gap-2 justify-start items-center">
                <span>Join samples as</span>

                <Select
                    v-model="app.outputMode"
                    :options="['columns', 'rows']"
                />
                <span>to form</span>
                <Select
                    v-model="app.tileMode"
                    :options="[{
                        name: 'full size',
                        value: 'full'
                    }, {
                        name: 'tiled',
                        value: 'tile'
                    }]"
                    optionValue="value"
                    optionLabel="name"
                />
                <span>cross-sections.</span>
            </div>
            <div
                v-if="app.tileMode === 'tile'"
                class="flex gap-2 justify-start items-center"
            >
                <span>Make </span>

                <Select
                    v-model="app.tileProportion"
                    :options="[{
                        name: 'square (1:1)',
                        value: 'square'
                    }, {
                        name: 'landscape (16:9)',
                        value: 'landscape'
                    }, {
                        name: 'portrait (9:16)',
                        value: 'portrait'
                    }]"
                    optionValue="value"
                    optionLabel="name"
                />
                <span>tiles optimized for</span>
                <!-- this used to be duration and resolution
                 buy quanity/quality makes more sense as a description of the tiles.
                 TODO: refactor components that depend on app.prioritize -->
                <Select
                    v-model="app.prioritize"
                    :options="[{
                        name: 'quantity',
                        value: 'quantity'
                    }, {
                        name: 'quality',
                        value: 'quality'
                    }]"
                    optionValue="value"
                    optionLabel="name"
                />
            </div>
            <ExplanatoryMessages
                style="max-width: 31.5rem;"
                :plan="tilePlan"
            ></ExplanatoryMessages>

        </div>

        <div class="flex flex-col items-start gap-2">
            <div
                v-if="tilePlan?.tiles?.length"
                :class="(app.outputMode == 'columns') ? 'tile-container-columns' : 'tile-container-rows'"
            >
                <Tile
                    v-for="tile in tilePlan.tiles"
                    :start="tile.start"
                    :end="tile.end"
                    :width="tilePlan.width"
                    :height="tilePlan.height"
                ></Tile>
            </div>



            <h3 class="text-xl">Are you ready?</h3>
            <button
                id="process-button"
                class="bg-blue-500 text-white px-4 py-2 rounded-md"
                @click="processVideo()"
            >Process</button>
        </div>

    </div>
</template>
<style scoped>

    span.sample-pixel-count {
        font-variant: small-caps;
        color: #10b981;
        border: 1px solid #10b981;
        border-radius: 0.25rem;
        padding: 0.25rem 0.5rem;
    }

    .tile-container-columns {
        display: flex;
        gap: 0.5rem;
    }

    .tile-container-rows {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }



    label {
        box-shadow: rgba(0, 30, 43, 0.3) 0px 4px 10px -4px;
        padding: 1.5rem;
        border-radius: 1rem;
        cursor: pointer;
        outline: 2px solid #eee;
    }

    label span {
        font-weight: 700;
    }

    label:hover {
        outline: 2px solid lightgreen;
    }

    label.activeLabel {
        outline: 2px solid #10b981;
    }

    label svg {
        background: #ddd;
        width: 6rem;
        margin-left: auto;
    }

    label.activeLabel svg {
        background: #10b981;
    }

    label svg line,
    label svg path {
        fill: none;
        stroke: #fff;
        stroke-miterlimit: 10;
    }

    :deep(.p-inputnumber-input) {
        width: 4rem;
    }
</style>

================
File: src/components/SkipMessage.vue
================
<script setup>

    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

    const { plan } = defineProps({
        plan: Object
    })

</script>
<template>
    <div
        class="flex items-center gap-1 cursor-default"
        v-tooltip.left="`${plan.length} ${app.tileProportion} ${plan.length == 1 ? 'tile' : 'tiles'} at full resolution (${plan.width}x${plan.height}) takes up ${app.frameCount - plan.skipping} of ${app.frameCount} possible sample ${app.samplingMode}. ${plan.skipping} ${app.samplingMode} from frames ${app.frameCount - plan.skipping + 1}-${app.frameCount} do not form a full tile and will be skipped.`"
    >
        <span class="material-symbols-outlined">step_over</span>
        <span>Skipping</span>
        <span> {{ plan.skipping }} frames</span>
    </div>
</template>

<style scoped>
    .small-icon {
        font-size: 1.125rem;
    }
</style>

================
File: src/components/StatusBox.vue
================
<script setup>
    // import { compute } from 'three/webgpu';
    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store


</script>
<template>
    <div
        v-for="status in Object.entries(app.status)"
        id="status-box"
    >
        <h4 v-if="status[0]">{{ status[0] }}</h4>
        <div
            v-if="status[1]"
            v-html="status[1]"
        ></div>


    </div>
</template>
<style>
    #status-box {
        padding: 1rem;
        border: 1px solid #ccc;
        border-radius: 0.5rem;
    }
</style>

================
File: src/components/Tile.vue
================
<script setup>

    import { computed } from 'vue';
    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

    const { width, height } = defineProps({
        width: Number,
        height: Number,
        start: Number,
        end: Number,
        aspectRatio: {
            type: String,
            default: '1/1'
        },
        skip: {
            type: Boolean,
            default: false
        }
    })


    const tileClasses = computed(() => {
        let classes = ['tile']
        if (app.outputMode == 'rows') classes.push('tile-row')
        if (app.outputMode == 'columns') classes.push('tile-column')
        if (app.tileMode == 'full') {
            classes.push('tile-full')
        }
        else {
            if (app.tileProportion == 'square') classes.push('tile-square')
            if (app.tileProportion == 'landscape') classes.push('tile-landscape')
            if (app.tileProportion == 'portrait') classes.push('tile-portrait')
        }
        return classes
    })



    const tileStyle = computed(() => {
        if (app.tileMode == 'full') {
            if (app.outputMode == 'columns') {
                return `aspect-ratio: ${app.frameCount}/${app.samplePixelCount};`
            }
            if (app.outputMode == 'rows') {
                return `aspect-ratio: ${app.samplePixelCount}/${app.frameCount};`
            }
        }
        return ''
    })

</script>
<template>

    <div
        :class="tileClasses"
        :style="tileStyle"
        class="flex flex-col items-center justify-center"
    >

        <div class="flex items-center">
            <span class="small-icon material-symbols-outlined">arrow_range</span>
            <span>{{ width }}</span>
            <span style="font-variant: small-caps;">px</span>
        </div>
        <div class="flex items-center">
            <span class="small-icon flipped-icon material-symbols-outlined">arrow_range</span>
            <span> {{ height }} </span>
            <span style="font-variant: small-caps;">px</span>
        </div>
        <div class="flex items-center">

            <span style="font-variant: small-caps;">f</span>
            <span> {{ start }} </span>
            <span class="small-icon material-symbols-outlined">double_arrow</span>
            <span style="font-variant: small-caps;">f</span>
            <span> {{ end }} </span>
        </div>
    </div>

</template>
<style scoped>
    .small-icon {
        font-size: 1.125rem;
    }

    .flipped-icon {
        transform: rotate(90deg);
    }


    .tile {
        border: 2px solid white;
        padding: 0.5rem;
        min-height: 120px;
        min-width: 120px;
    }

    .tile-column {
        background: repeating-linear-gradient(90deg,
                #efefef,
                #efefef 0.25rem,
                #ddd 0.25rem,
                #ddd 0.5rem);
    }

    .tile-row {
        background: repeating-linear-gradient(0deg,
                #efefef,
                #efefef 0.25rem,
                #ddd 0.25rem,
                #ddd 0.5rem);
        /* background-size: 100% 50%;
        animation: move-stripes 4s linear infinite; */
    }

    /* While It is possible to make the stripes animate 
    I don't think it helps to communicate the concept per-se. */

    /* @keyframes move-stripes {
        0% {  background-position: 0 0;  } 
        100% { background-position: 0 100%;  }
    } */

    .tile-square {
        aspect-ratio: 1/1;
    }

    .tile-landscape {
        aspect-ratio: 16/9;
    }

    .tile-portrait {
        aspect-ratio: 9/16;
    }

</style>

================
File: src/components/UploadArea.vue
================
<script setup>
    import { ref } from 'vue';

    import { useAppStore } from '../stores/appStore';
    const app = useAppStore()  // Pinia store

    const fileInput = ref(null);
    // Add a method to handle the file selection
    const handleFileChange = () => {
        const files = fileInput.value.files;
        if (files && files.length > 0) {
            app.set('file', files[0])
            app.set('fileURL', URL.createObjectURL(files[0]))
            app.set('currentTab', '1')
        }
    };
</script>

<template>
    <div class="flex gap-4 items-center justify-center w-auto border-2 border-gray-300 rounded-md p-4">
        <h3 class="flex items-center gap-2 text-xl"><img
                src="/video-upload.svg"
                alt="Upload Video"
            ><span>Upload Video</span></h3>
        <span>Drag/Drop anywhere</span>
        <span>or</span>
        <button
            @click=" fileInput.click()"
            class="bg-blue-500 text-white px-4 py-2 rounded-md"
            id="browse-button"
        >Browse...</button>
        <input
            ref="fileInput"
            type="file"
            id="file-input"
            style="display: none;"
            accept="video/*"
            @change="handleFileChange"
        >
        <div id="file-info">
        </div>
    </div>
</template>

================
File: src/components/VideoPlayer.vue
================
<script setup>
    import { ref, watch, onMounted, onUnmounted, computed } from 'vue';

    const props = defineProps({
        url: {
            type: String,
            required: true
        },
        /* playbackTime allows the context to pass in 
        a synchronized time for multiple videos */
        playbackTime: {
            type: Number,
            default: null
        },
        isPlaying: {
            type: Boolean,
            default: false
        },
        isPrimary: {
            type: Boolean,
            default: false
        }
    });

    const emit = defineEmits(['playback-state-change']);

    const videoElement = ref(null);
    const isReady = ref(false);
    const currentTime = ref(0); // New reactive property

    let animationFrame = null;

    // Computed property for current time display
    const currentTimeDisplay = computed(() => {
        return currentTime.value.toFixed(1);
    });


    // Emit playback state 
    // NOTE: this will only be used by the first/primary video
    function emitPlaybackState() {
        if (videoElement.value) {
            emit('playback-state-change', {
                currentTime: videoElement.value.currentTime,
                playing: !videoElement.value.paused
            });
        }
    }

    // Track playback using requestAnimationFrame for smoother updates
    function trackPlayback() {
        if (videoElement.value && !videoElement.value.paused) {
            emitPlaybackState();
        }
        animationFrame = requestAnimationFrame(trackPlayback);
    }

    onMounted(() => {
        if (videoElement.value) {
            videoElement.value.addEventListener('loadedmetadata', () => {
                isReady.value = true;
                if (props.isPrimary) {
                    emitPlaybackState();
                    trackPlayback();
                }


                setInterval(() => {
                    currentTime.value = videoElement.value.currentTime;
                }, 100);

            });

            if (props.isPrimary) {
                videoElement.value.addEventListener('play', emitPlaybackState);
                videoElement.value.addEventListener('pause', emitPlaybackState);
            }
        }
    });

    onUnmounted(() => {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
        if (videoElement.value && props.isPrimary) {
            videoElement.value.removeEventListener('loadedmetadata', emitPlaybackState);
            videoElement.value.removeEventListener('play', emitPlaybackState);
            videoElement.value.removeEventListener('pause', emitPlaybackState);
        }
    });

    // Watch for global playback time changes
    watch(
        () => props.playbackTime,
        (newTime) => {
            if (isReady.value && videoElement.value) {
                const timeDifference = Math.abs(videoElement.value.currentTime - newTime);
                // Threshold to prevent minor adjustments
                if (timeDifference > 0.1) {
                    videoElement.value.currentTime = newTime;
                }
            }
        }
    );


    // Watcher for global play/pause commands
    watch(
        () => props.isPlaying,
        (playing) => {
            if (isReady.value && videoElement.value) {
                if (playing && videoElement.value.paused) {
                    handlePlay();
                } else if (!playing && !videoElement.value.paused) {
                    handlePause();
                }
            }
        }
    );

    // Function to handle play action with error handling
    const handlePlay = async () => {
        try {
            await videoElement.value.play();
        } catch (error) {
            console.error('Error playing video:', error);
        }
    };

    // Function to handle pause action
    const handlePause = () => {
        videoElement.value.pause();
    };

</script>
<template>
    <div class="video-container">
        <video
            ref="videoElement"
            v-if="url"
            :src="url"
            controls
            loop
            autoplay
        ></video>
        <!-- <p>{{ currentTimeDisplay }} seconds</p> -->
    </div>
</template>
<style scoped>
    video {
        max-width: 100%;
    }

    .video-container {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
</style>

================
File: src/composables/useNiceFormat.js
================
export function useNiceFormat() {

    const niceDuration = (duration) => {
        const hours = Math.floor(duration / 3600)
        const minutes = Math.floor((duration % 3600) / 60).toString().padStart(2, '0')
        const seconds = Math.floor(duration % 60).toString().padStart(2, '0')
        const milliseconds = Math.floor((duration % 1) * 1000).toString().padStart(3, '0')

        let result = `${minutes}:${seconds}.${milliseconds}`

        if (hours > 0) {
            result = `${hours}:${result}`
        }

        return result
    }

    const niceBitRate = (bitRate) => {
        const kb = bitRate / 1000
        const mb = kb / 1000
        return `${mb.toFixed(2)} Mbps`
    }

    const niceFrameRate = (frameRate) => {
        if (!frameRate) return 0
        const [num, den] = frameRate.split('/').map(Number)
        const frameRateNum = num / den
        return frameRateNum.toFixed(2)
    }
    /**vp08		VP            WebM / Google
    vp09		VP            WebM / Google
    hvc1		HEVC          High Efficiency Video Coding / H.265
    avc1		AVC           Advanced Video Coding / H.264
    av01		AV            Alliance for Open Media / AOMedia Video 1 */
    const niceCodec = (codec) => {
        if (codec?.startsWith('avc')) {
            //(Advanced Video Coding)
            return 'H.264 / AVC'
        }
        else if (codec?.startsWith('av01')) {
            // (Alliance for Open Media)
            return 'AV1 / AOMedia Video 1'
        }
        else if (codec?.startsWith('hvc1') || codec?.startsWith('hev1')) {
            // (High Efficiency Video Coding)
            return 'H.265 / HEVC'
        }
        else if (codec?.startsWith('vp8')) {
            return 'VP8 / WebM / Google'
        }
        else if (codec?.startsWith('vp9') || codec?.startsWith('vp09')) {
            return 'VP9 / WebM / Google'
        }
        else {
            return codec
        }
    }

    return {
        niceDuration,
        niceBitRate,
        niceFrameRate,
        niceCodec
    }
}

================
File: src/composables/useTilePlan.js
================
import { computed } from 'vue';
import { useAppStore } from '../stores/appStore';

// The tilePlan is initially a computed property
// so as to be able to reactively update the user interface with helpful preview
// information about the tile plan.
// afterwards (e.g. in the videoProcessor) it will be baked  into app.tilePlan 
// so that processing can occur reliably without further mutation.

export function useTilePlan() {
    const app = useAppStore(); // Pinia store

    const tilePlan = computed(() => {
        const plan = {
            length: 0,
            width: 0,
            height: 0,
            tiles: [],
            notices: [],
            isScaled: false,
            scaleFrom: 0,
            scaleTo: 0,
            rotate: 0, // Rotation angle (0 or 90 degrees)
            skipping: 0, // Number of frames being skipped
        };

        // Ensure necessary data is available
        if (
            !app.fileInfo?.width ||
            !app.fileInfo?.height ||
            !app.frameCount ||
            !app.tileProportion
        ) {
            plan.notices.push('Insufficient data to calculate tile plan.');
            return plan;
        }

        // Determine rotation based on samplingMode and outputMode
        if (app.samplingMode !== app.outputMode) {
            plan.rotate = 90;
        }

        // Determine aspect ratio based on tileProportion
        let aspectRatio;
        if (app.tileProportion === 'square') {
            aspectRatio = 1;
        } else if (app.tileProportion === 'landscape') {
            aspectRatio = 16 / 9;
        } else if (app.tileProportion === 'portrait') {
            aspectRatio = 9 / 16;
        } else {
            plan.notices.push('Invalid tile proportion.');
            return plan;
        }

        // Initialize variables
        let framesPerTile; // Number of frames per tile (temporal side)
        let spatialSide = app.samplePixelCount; // Spatial side length (width or height based on samplingMode)
        let maxQualityTiles; // Maximum number of tiles for quality reference

        // Begin processing based on tileMode
        if (app.tileMode === 'tile') {
            // Nested hierarchy: tileMode > samplingMode > outputMode > prioritize
            if (app.samplingMode === 'rows') {
                if (app.outputMode === 'rows') {
                    framesPerTile = Math.floor(spatialSide / aspectRatio);
                    maxQualityTiles = Math.floor(app.frameCount / framesPerTile);
                    // Sampling rows, outputting rows
                    if (app.prioritize === 'quality') {
                        // Prioritize quality
                        plan.isScaled = false;
                        plan.width = spatialSide; // Spatial side
                        plan.height = framesPerTile; // Temporal side  
                        plan.length = maxQualityTiles;
                    } else if (app.prioritize === 'quantity') {
                        // Prioritize quantity 
                        plan.length = maxQualityTiles + 1;
                        // Recalculate framesPerTile
                        framesPerTile = Math.floor(app.frameCount / plan.length);
                        plan.height = framesPerTile; // Temporal side
                        plan.width = Math.floor(plan.height * aspectRatio); // Spatial side 
                        plan.isScaled = true;
                        plan.scaleFrom = spatialSide;
                        plan.scaleTo = plan.width;
                    }
                } else if (app.outputMode === 'columns') {
                    framesPerTile = Math.floor(spatialSide * aspectRatio);
                    maxQualityTiles = Math.floor(app.frameCount / framesPerTile);

                    // Sampling rows, outputting columns (rotation)
                    if (app.prioritize === 'quality') {
                        // Prioritize quality
                        plan.isScaled = false;
                        plan.height = spatialSide; // Spatial side
                        plan.width = framesPerTile // Temporal side 
                        plan.length = maxQualityTiles;
                    } else if (app.prioritize === 'quantity') {
                        // Prioritize quantity
                        plan.length = maxQualityTiles + 1;
                        // Recalculate framesPerTile
                        framesPerTile = Math.floor(app.frameCount / plan.length);
                        plan.width = framesPerTile; // Temporal side
                        // plan.height = Math.floor(plan.width * aspectRatio); // Spatial side 
                        plan.height = Math.floor(plan.width / aspectRatio); // Spatial side 
                        plan.isScaled = true;
                        plan.scaleFrom = spatialSide;
                        plan.scaleTo = plan.height;
                    }
                }
            } else if (app.samplingMode === 'columns') {
                if (app.outputMode === 'rows') {
                    // The adjusted aspect ratio did not always work,
                    // in some cases I had to revert back to the original aspect ratio 
                    // in order to get the desired behaviour 
                    framesPerTile = Math.floor(spatialSide / aspectRatio);
                    maxQualityTiles = Math.floor(app.frameCount / framesPerTile);
                    // Sampling columns, outputting rows (rotation)
                    if (app.prioritize === 'quality') {
                        // Prioritize quality
                        plan.isScaled = false;
                        plan.width = spatialSide; // Spatial side
                        plan.height = framesPerTile // Temporal side 
                        plan.length = maxQualityTiles;
                    } else if (app.prioritize === 'quantity') {
                        // Prioritize quantity
                        plan.length = maxQualityTiles + 1;
                        // Recalculate framesPerTile
                        framesPerTile = Math.floor(app.frameCount / plan.length);
                        plan.height = framesPerTile; // Temporal side
                        plan.width = Math.floor(plan.height * aspectRatio); // Spatial side   
                        plan.isScaled = true;
                        plan.scaleFrom = spatialSide;
                        plan.scaleTo = plan.width;
                    }
                } else if (app.outputMode === 'columns') {
                    framesPerTile = Math.floor(spatialSide * aspectRatio);
                    maxQualityTiles = Math.floor(app.frameCount / framesPerTile);
                    // Sampling columns, outputting columns
                    if (app.prioritize === 'quality') {
                        // Prioritize quality
                        plan.isScaled = false;
                        plan.height = spatialSide; // Spatial side
                        plan.width = framesPerTile; // Temporal side  
                        plan.length = maxQualityTiles;
                    } else if (app.prioritize === 'quantity') {
                        // Prioritize quantity
                        plan.length = maxQualityTiles + 1;
                        // Recalculate framesPerTile
                        framesPerTile = Math.floor(app.frameCount / plan.length);
                        plan.width = framesPerTile; // Temporal side
                        plan.height = Math.floor(plan.width / aspectRatio); // Spatial side 
                        plan.isScaled = true;
                        plan.scaleFrom = spatialSide;
                        plan.scaleTo = plan.height;
                    }
                }
            }

            // Generate tile frame ranges
            plan.tiles = Array.from({ length: plan.length }, (_, i) => {
                const startFrame = i * framesPerTile + 1;
                const endFrame = (i + 1) * framesPerTile;
                return {
                    start: startFrame,
                    end: endFrame,
                };
            });

            // Handle common calculations after nesting
            if (plan.isScaled) {
                // Ensure framesPerTile and plan.length are valid
                if (framesPerTile < 1 || plan.length < 1) {
                    const framesNeeded = framesPerTile || 1;
                    const framesShort = framesNeeded - app.frameCount;
                    plan.notices.push(
                        `Not enough frames to create tiles with the current settings. Each tile requires ${framesNeeded} frames, but only ${app.frameCount} frames are available. You are short by ${framesShort} frames.`
                    );
                    plan.skipping = app.frameCount; // All frames are skipped
                    return plan;
                }

                // All frames are used
                plan.skipping = 0;
            } else {

                if (framesPerTile < 1 || plan.length < 1) {
                    const framesNeeded = framesPerTile || 1;
                    const framesShort = framesNeeded - app.frameCount;
                    plan.notices.push(
                        `Not enough frames to create a single tile with the current settings. Each tile requires ${framesNeeded} frames, but only ${app.frameCount} frames are available. You are short by ${framesShort} frames.`
                    );
                    plan.skipping = app.frameCount; // All frames are skipped
                    return plan;
                }

                // Calculate skipped frames
                const usedFrames = plan.length * framesPerTile;
                plan.skipping = app.frameCount - usedFrames;
            }
        } else if (app.tileMode === 'full') {
            // Full tile mode: one tile covering all frames
            plan.length = 1;
            plan.isScaled = false;
            plan.scaleFrom = spatialSide;
            plan.scaleTo = spatialSide;
            plan.tiles = [{ start: 1, end: app.frameCount }];
            plan.skipping = 0;

            // Determine tile dimensions based on samplingMode and outputMode
            if (app.samplingMode === 'rows') {
                if (app.outputMode === 'rows') {
                    plan.width = spatialSide; // Spatial side
                    plan.height = app.frameCount; // Temporal side
                } else if (app.outputMode === 'columns') {
                    plan.height = spatialSide; // Spatial side
                    plan.width = app.frameCount; // Temporal side
                }
            } else if (app.samplingMode === 'columns') {
                if (app.outputMode === 'rows') {
                    plan.width = spatialSide; // Spatial side
                    plan.height = app.frameCount; // Temporal side
                } else if (app.outputMode === 'columns') {
                    plan.height = spatialSide; // Spatial side
                    plan.width = app.frameCount; // Temporal side
                }
            }
        } else {
            plan.notices.push('Invalid tile mode.');
            return plan;
        }

        // Ensure dimensions are integers
        plan.width = Math.floor(plan.width);
        plan.height = Math.floor(plan.height);
        plan.scaleTo = Math.floor(plan.scaleTo);

        return plan;
    });

    return {
        tilePlan,
    };
}

================
File: src/composables/useTilePlan.md
================
## Notes about the purpose and approach of Use Tile Plan

   given a combination of settings
     and the file's metadata, calculate
     the dimensions and frame ranges
     for each tile in a tile series

     When tile mode is 'full' there is only one tile
     and things are relatively simple.
     we only need to map app.frameCount onto tile height or width
     depending on the samplingMode
     and also map samplePixelCount onto the other dimension.

     When tile mode is 'tile' there are multiple tiles
     that break up the otherwise full output into smaller parts
     the dimensions of the tiles are constrained by various settings

     For square tiles, the width and height are the same
     and therefore outputMode may be less relevant
     when it comes to calculating tile dimensions.

     We are using "sample" to refer to 1D array of pixels 
     sampled from one frame of video. This could be either:
     - a row of pixels, when samplingMode == rows
       samplePixelCount is then width of the input video
     - a column of pixels, when samplingMode == columns
       samplePixelCount is then height of the input video

     It may be useful to think about tiles as having:
     1. A spatial side that corresponds to the width or height of a source frame
     - if outputMode is rows, the width of the tile is the spatial side
     - if outputMode is columns, the height of the tile is the spatial side
     2. A temporal side that corresponds to multiple frames in the source video
     - if outputMode is rows, the height of the tile is the temporal side
     - if outputMode is columns, the width of the tile is the temporal side

     When quality is prioritized, 
     We try to preserve the full sample resolution i.e. samplePixelCount
         NOTE: this will have been derived from either rows or columns 
         depending on the chosen samplingMode
     Tile dimensions are then as follows:
     - First dimension: samplePixelCount 
     - Second dimension: calculated based on tileProportion and outputMode
     If outputMode is 'rows', samplePixelCount becomes the width of the tile
      in landscape the height is 9/16 of the width
      in portrait the height is 16/9 of the width
      for square tiles, the width and height are the same
     If outputMode is 'columns', samplePixelCount becomes the height of the tile
      in landscape the width is 16/9 of the height
      in portrait the width is 9/16 of the height
      for square tiles, the width and height are the same 
     Having thus calculated the tile dimensions
     we know how many pixels are needed for the temporal side of each tile
     we will need the same number of frames in order to fully populate the tile with pixels.
     we may have sufficient frames to construct multiple tiles
     to check the maximum number of constructable tiles
     We take the number of available samples (i.e. app.frameCount)
     and divide by the number of pixels needed for the temporal side of each tile
     this will tell us how many tiles are possible.
     we might have some frames left over but we will discard them since
     we are prioritizing quality over quantity.
     it's also possible that there are insufficient frames to construct a single tile
     in which case it may be better to priotitize quantity over quality.
 
     when quantity is prioritized,
     We downsample the sampled pixels to such a dimension
     as would allow for one extra tile to fit within app.frameCount
     We must therefore first determine how many tiles could be constructed
     if we were using the full sample resolution.
     We might need to borrow some initial logic from the "quality" case
     so as to have a point of reference.
     whatever the maximum number of possible tiles is for "quality"
     we will add one to it,
     and this becomes the target number of tiles for "quantity" case.
     Once we have the target number of tiles, 
     we can calculate the actual dimensions of the tiles
     we would take app.frameCount and divide by the target number of tiles
     this will give us the number of frames that can be allocated to each tile
     on its temporal side. 
     if outputMode is 'rows', the height of the tile is the temporal side
     -in this case we would need to calculate the width of the tile
     -if the tileProportion is square, the width and height are the same
     -if the tileProportion is landscape, the width is 16/9 of the height
     -if the tileProportion is portrait, the width is 9/16 of the height
     if outputMode is 'columns', the width of the tile is the temporal side
     -in this case we would need to calculate the height of the tile
     -if the tileProportion is square, the width and height are the same
     -if the tileProportion is landscape, the height is 9/16 of the width
     -if the tileProportion is portrait, the height is 16/9 of the width
     
     regarding the tile ranges, we need to know the start and end frame numbers
     for each tile. 
     we would need to iterate over the number of tiles
     and for each tile, calculate the start and end frame numbers
     the start frame number is the index of the tile 
     multiplied by the number of frames per tile (i.e. the number pixels on the temporal side)
     plus one (because frame numbers are not zero indexed but start from 1)
     the end frame number is the index of the tile plus one
     multiplied by the number of frames per tile (i.e. the number of pixels on the temporal side)

================
File: src/main.js
================
import { createPinia } from 'pinia';
import { createApp } from 'vue';
import PrimeVue from 'primevue/config';
import Aura from '@primevue/themes/aura';
import App from './App.vue';


// Material Icons 
import { loadMaterialSymbols } from './modules/iconLoader';
// Pass an array icon names to be loaded via Google Fonts CDN
loadMaterialSymbols([
    'home', 'palette', 'settings', 'info', 'rotate_90_degrees_cw',
    'step_over', 'close_fullscreen', 'open_in_full', 'warning',
    'video_file', 'frame_source', 'barcode', 'timer', 'speed',
    'calculate', 'view_compact', 'rotate_right', 'equalizer',
    'arrow_range', 'double_arrow'
])
// Note: we could also import the entire set, but the bundle is too big.
// import 'material-symbols/outlined.css';


const app = createApp(App);

const pinia = createPinia();
app.use(pinia);


app.use(PrimeVue, {
    theme: {
        preset: Aura
    }
})


import Tooltip from 'primevue/tooltip';
app.directive('tooltip', Tooltip);

app.mount('#app');

================
File: src/modules/blobDownloader.js
================
// Given a blobURL, download it as a file.

const downloadBlob = (blobURL) => {
    let a = document.createElement('a');
    a.style.display = 'none';
    a.href = blobURL;
    a.download = 'output.webm';
    document.body.appendChild(a);
    a.click();
};

export { downloadBlob };

================
File: src/modules/canvasPool.js
================
// TODO: account for cases where dimensions are odd numbers
// by adjusting them to ensure even number of pixels
// One Possibility: if (dimension % 2 !== 0) { dimension--; }

export function createCanvasPool(size, width, height) {
    const pool = [];

    // Pre-create canvases
    for (let i = 0; i < size; i++) {
        pool.push(createCanvas(width, height));
    }

    // Create a new canvas
    function createCanvas(width, height) {
        let canvas = new OffscreenCanvas(width, height);
        return canvas;
    }

    // Retrieve a canvas from the pool
    function getCanvas() {
        if (pool.length > 0) {
            return pool.pop();
        } else {
            console.warn("Canvas pool exhausted! Creating a new canvas.");
            return createCanvas(width, height); // Create a new one if pool is empty
        }
    }

    // Return a canvas to the pool
    function releaseCanvas(canvas) {
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        pool.push(canvas); // Add the canvas back to the pool
    }


    // TODO / NOTE: I wonder if we can track the canvases that are in use
    // so as to be able to centrally release them all at once
    // e.g. when we are done with a tile.
    // This might be an antipattern though; look into it


    // Expose public API
    return {
        getCanvas,
        releaseCanvas,
    };
}

================
File: src/modules/dragAndDropHandler.js
================
export function dragAndDrop(handleFile) {

  const preventDefaults = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const highlight = () => {
    document.body.classList.add('hover');
  };

  const unhighlight = () => {
    document.body.classList.remove('hover');
  };

  const handleDrop = (e) => {
    preventDefaults(e);
    handleFile(e.dataTransfer.files[0]);
  };

  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    document.body.addEventListener(eventName, preventDefaults, false);
  });

  ['dragenter', 'dragover'].forEach(eventName => {
    document.body.addEventListener(eventName, highlight, false);
  });

  ['dragleave', 'drop'].forEach(eventName => {
    document.body.addEventListener(eventName, unhighlight, false);
  });

  document.body.addEventListener('drop', handleDrop, false);


}

================
File: src/modules/frameProcessor.js
================
import { useAppStore } from '../stores/appStore';


// Given a video frame, and a frame number
// extract samples from the frame
// as per the tileplan
// and write each sample to the correct canvas
// also as per the tile plan.

// if canvasses don't exist yet for the tile in question
// rely on the canvas pool to provide canvasses

// if a tile is finished, the encode process needs to start
// to assemble all  canvasses into an animation. 
// then clear the canvasses and re-use them for the next tile.
// or else delete the canvasses and make new ones.

const processFrame = (videoFrame, frameNumber, tileNumber) => {


    const app = useAppStore()  // Pinia store  


    // Let's normalize the frameNumber to the tile's range
    // so we know where to draw the sample in the destination tile  
    let drawLocation = frameNumber - app.tilePlan.tiles[tileNumber].start;
    // NOTE: ↓ Later we also have a sampleLocation  (unique to each canvas)

    // if we don't have canvasses for this tile yet, 
    // allocate them from the pool, and set the orientation
    if (app.canvasses[tileNumber] == undefined) {
        for (let i = 0; i < app.crossSectionCount; i++) {
            let canvas = app.canvasPool.getCanvas()
            let ctx = canvas.getContext('2d');
            if (app.tilePlan.rotate !== 0) {
                // Translate to Center, 
                // Rotate by 90 degrees clockwise (or counterclockwise)
                // to achieve mapping of top-to-bottom ⇔ left-to-right
                // Translate back to the corner (respecting orientation swap)
                ctx.translate(app.tilePlan.width / 2, app.tilePlan.height / 2);
                if (app.samplingMode === 'rows') ctx.rotate(app.tilePlan.rotate * Math.PI / 180);
                if (app.samplingMode === 'columns') ctx.rotate(-app.tilePlan.rotate * Math.PI / 180);
                ctx.translate(-app.tilePlan.height / 2, -app.tilePlan.width / 2);
            }
            app.allocateCanvas(tileNumber, canvas);
        }
    }

    // we can be confident that the canvasses exist now
    // and are correctly oriented.

    app.canvasses[tileNumber].forEach((canvas, canvasNumber) => {

        // We will sample pixels from a different y-location for each canvas    
        // Cosine distribution  (This creates a gentle sway back and forth)
        // TODO: audit this Math to make sure it uses the full range properly
        // A normalized index describes the canvas number as a fraction of the total canvasses
        // (A number between 0 and 1). We multiply this by PI to get a number between 0 and PI
        // This is a useful range for cosine functions.
        let normalizedIndex = (canvasNumber / (app.crossSectionCount - 1)) * Math.PI;
        // if we are sampling rows, they are distributed along the video height
        // if we are sampling columns, they are distributed along the video width
        let distributionRange = 0
        if (app.samplingMode === 'rows') distributionRange = app.fileInfo.height;
        if (app.samplingMode === 'columns') distributionRange = app.fileInfo.width;
        let sampleLocation = (Math.cos(normalizedIndex) + 1) / 2 * (distributionRange - 1);


        let ctx = canvas.getContext('2d')


        // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
        // When sample and tile dimensions differ, drawImage ⟹ scaling effects

        if (app.samplingMode === 'columns') {
            if (app.outputMode === 'columns') {
                const sx = sampleLocation           // Source x
                const sy = 0                        // Source y
                const sw = 1                        // Source width
                const sh = app.fileInfo.height      // Source height
                const dx = drawLocation             // Destination x
                const dy = 0                        // Destination y
                const dw = 1                        // Destination width
                const dh = app.tilePlan.height          // Destination height
                ctx.drawImage(videoFrame, sx, sy, sw, sh, dx, dy, dw, dh);
            }
            else if (app.outputMode === 'rows') {
                // We have already rotated the canvas
                // to account for samplingMode != outputMode
                // the lets us write columns to rows
                // NOTE: we still need to use app.tilePlan.width for the height
                // since the canvas is rotated.
                const sx = sampleLocation           // Source x
                const sy = 0                        // Source y
                const sw = 1                        // Source width
                const sh = app.fileInfo.height      // Source height
                const dx = drawLocation             // Destination x
                const dy = 0                        // Destination y
                const dw = 1                        // Destination width
                const dh = app.tilePlan.width           // ***Destination height
                ctx.drawImage(videoFrame, sx, sy, sw, sh, dx, dy, dw, dh);
            }
        }
        else if (app.samplingMode === 'rows') {
            if (app.outputMode === 'rows') {
                const sx = 0                        // Source x
                const sy = sampleLocation           // Source y
                const sw = app.fileInfo.width       // Source width
                const sh = 1                        // Source height
                const dx = 0                        // Destination x
                const dy = drawLocation             // Destination y
                const dw = app.tilePlan.width           // Destination width
                const dh = 1                        // Destination height
                ctx.drawImage(videoFrame, sx, sy, sw, sh, dx, dy, dw, dh);
            }
            else if (app.outputMode === 'columns') {
                // We have already rotated the canvas
                // to account for samplingMode != outputMode
                // the lets us write rows to columns
                // NOTE: we still need to use app.tilePlan.height for the height
                // since the canvas is rotated.
                const sx = 0                        // Source x
                const sy = sampleLocation           // Source y
                const sw = app.fileInfo.width       // Source width
                const sh = 1                        // Source height
                const dx = 0                        // Destination x
                const dy = drawLocation             // Destination y
                const dw = app.tilePlan.height          // Destination width
                const dh = 1                        // Destination height
                ctx.drawImage(videoFrame, sx, sy, sw, sh, dx, dy, dw, dh);
            }
        }
    })
    // TODO: make sure all the drawImage calls are finished before closing the videoFrame

    videoFrame.close();



    // return ?
}

export { processFrame }

================
File: src/modules/iconLoader.js
================
// let's use the CDN to import a list of icons from Google 
// icon names are sorted as per Google requirements 

const loadMaterialSymbols = (iconNames = ['home']) => {
    const baseUrl = 'https://fonts.googleapis.com/css2';
    const fontFamily = 'Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200';

    iconNames = iconNames.sort();
    const linkElement = document.createElement('link');
    linkElement.rel = 'stylesheet';
    linkElement.href = `${baseUrl}?family=${fontFamily}&icon_names=${iconNames}&display=block`
    document.head.appendChild(linkElement);
}

export { loadMaterialSymbols }

================
File: src/modules/metaDataExtractor.js
================
import { useAppStore } from '../stores/appStore';
import { demuxer } from './webDemuxer.js';

const getMetaData = async () => {

    const app = useAppStore()  // Pinia store 

    // reset framecount for a new file
    app.set('frameCount', 0)
    app.set('fileInfo', null)

    try {
        app.log(`Loading Demuxer`)
        await demuxer.load(app.file);
        app.log(`Loading Stream Info`)
        let info = await demuxer.getAVStream();
        console.log('getAVStream', info)
        app.set('frameCount', Number(info.nb_frames))
        app.set('fileInfo', { ...info, name: app.file.name })
        app.log(`Loading Video Decoder Config`)
        let config = await demuxer.getVideoDecoderConfig();
        console.log('getVideoDecoderConfig', config)
        app.set('config', config)


    } catch (error) {
        console.error('Failed to get file meta data:', error);
    }
}

export { getMetaData }

================
File: src/modules/resourceMonitor.js
================
import { useAppStore } from '../stores/appStore';
import { videoDecoder } from './videoDecoder.js';
const resourceUsageReport = async () => {

    const app = useAppStore();

    let memoryUsage = '';
    // if using google chrome, show memory usage
    if (performance.memory) {
        const { usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit } = performance.memory;
        memoryUsage = `Used: ${(usedJSHeapSize / 1024 / 1024).toFixed(2)} MB <BR/>
            Total: ${(totalJSHeapSize / 1024 / 1024).toFixed(2)} MB <BR/>
            Limit: ${(jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`
    }
    // update the status box with a snapshot of what's happening
    app.setStatus('Decoding', `
        Stream: ${app.readerIsFinished ? 'finished' : 'reading'}</br>
    FPS: ${app.fps} </br>
    CPU Cores: ${navigator.hardwareConcurrency} </br>
    Queue size: ${videoDecoder.decodeQueueSize}.<br/>
    Decoded frame: ${app.frameNumber} of ${app.frameCount}<br/> ${memoryUsage}
    `)
}

export { resourceUsageReport }

================
File: src/modules/videoDecoder.js
================
import { useAppStore } from '../stores/appStore.js';
import { processFrame } from './frameProcessor.js';
import { resourceUsageReport } from './resourceMonitor.js';
import { encodeVideo } from './videoEncoder.js';

const videoDecoder = new VideoDecoder({
    output: async (videoFrame) => {

        // if we were to move the decode process into a worker,
        // we would send the videoFrame back to the main thread
        // instead of processing it here.

        const app = useAppStore()
        app.frameNumber++;

        // to start, find the tile the current frame belongs to
        // based on the frame number, and tile range
        let tileNumber = app.tilePlan.tiles
            .findIndex(tile => app.frameNumber >= tile.start && app.frameNumber <= tile.end);

        processFrame(videoFrame, app.frameNumber, tileNumber);

        // update ram usage stats
        resourceUsageReport();

        if (app.frameNumber === app.tilePlan.tiles[tileNumber].end) {
            // If this is the last frame in the tile, 
            // we need to encode the canvasses into a video
            // and release the canvasses back to the pool
            // or else delete the canvasses and make new ones.
            await encodeVideo(tileNumber);
        }
        // app.resume()
    },
    error: e => console.error('Video decode error:', e)
});


const decodePackets = async (reader) => {
    const app = useAppStore()
    try {
        const { done, value } = await reader.read();

        if (done) {
            await videoDecoder.flush();
            app.log('Decoder flushed, all frames processed.');
            return;
        }
        //if (decoder.decodeQueueSize > 400) { await pauseDecode; }
        // Decode the video chunk
        let chunk = new EncodedVideoChunk({
            type: value.keyframe ? 'key' : 'delta',
            timestamp: value.timestamp,
            duration: value.duration,
            data: value.data,
            transfer: [value.data.buffer]
        })
        // console.log('Decoding chunk:', chunk);
        videoDecoder.decode(chunk);

        // Continue decoding the next packet
        await decodePackets(reader);

    } catch (readError) {
        console.error('Error while reading packets:', readError);
    }
}

export { videoDecoder, decodePackets }

================
File: src/modules/videoEncoder.js
================
import { useAppStore } from '../stores/appStore';
import { Muxer, ArrayBufferTarget } from 'webm-muxer';

const encodeVideo = async (tileNumber) => {

    const app = useAppStore()  // Pinia store 

    let muxer = new Muxer({
        target: new ArrayBufferTarget(),
        video: {
            codec: 'V_VP9',
            width: app.tilePlan.width,
            height: app.tilePlan.height
        },
        fastStart: 'in-memory'
    });

    let framesCompleted = 0;
    let videoEncoder = new VideoEncoder({
        output: (chunk, meta) => {
            framesCompleted++
            app.setStatus('Encoding', `Encoded frame ${framesCompleted} of ${sequencedFrames.length} in Tile ${tileNumber}`)
            muxer.addVideoChunk(chunk, meta)
        },
        error: e => console.error(e)
    });
    videoEncoder.configure({
        codec: 'vp09.00.10.08',
        width: app.tilePlan.width,
        height: app.tilePlan.height,
        bitrate: 3e6  // 3,000,000 bits per second
    });


    // Given a canvas and frame index, encode the frame using the videoEncoder
    const encodeFrame = (canvas, frameIndex) => {
        const frameRate = 30;  // Adjust frame rate as needed
        const frameDuration = 1e6 / frameRate;   // 1,000,000 microseconds per second / 30 frames per second. 
        const frame = new VideoFrame(canvas, {
            timestamp: frameIndex * frameDuration,
            duration: frameDuration
        });
        // Keyframe every 30 frames  
        videoEncoder.encode(frame, { keyFrame: frameIndex % 30 === 0 });
        frame.close()
    }

    // Create a single array that references each canvas twice 
    // First in natural forward order and then and again reverse
    // this results in a loopable back-and-forth effect in the final video
    const sequencedFrames = [
        ...app.canvasses[tileNumber],
        ...app.canvasses[tileNumber].slice().reverse()
    ];

    sequencedFrames.forEach((canvas, frameIndex) => encodeFrame(canvas, frameIndex))
    await videoEncoder.flush();
    muxer.finalize();


    app.log(`Creating Blob...`)
    let blob = new Blob([muxer.target.buffer])

    app.createBlob(tileNumber, {
        blob,
        url: URL.createObjectURL(blob)
    })

    app.set('currentTab', '3')


}

export { encodeVideo }

================
File: src/modules/videoProcessor.js
================
import { useAppStore } from '../stores/appStore';

import { useTilePlan } from '../composables/useTilePlan';

import { demuxer } from './webDemuxer.js';
import { videoDecoder, decodePackets } from './videoDecoder.js';

import { createCanvasPool } from './canvasPool.js';



/**Video Processing

CANVAS POOL
During construction each tile needs (app.crossSectionCount) # of canvasses
Therefore let's establish a pool of canvasses to be used for building tiles
Canvas dimensions are defined in tilePlan 
Populate the pool with a reasonable number of canvasses.
    - e.g. based on available RAM and Tile dimensions.
    - as a baseline, make enough canvasses for 3 tiles.
        - i.e. 3 * app.crossSectionCount
Auto-Allocate canvasses for currentTile and the nextTile
Store In-use canvasses in app.canvasses[tileNumber][canvasNumber]
On tile completion:
 -release canvasses back to the pool.
    canvasPool.releaseCanvas(app.canvasses[tileNumber][canvasNumber]);
 -remove references to tile canvasses from app.canvasses
    remove(app.canvasses[tileNumber])

--

Given a decoded frame, and frame number
Look up the tile to which it belongs.
-Use the frame number range in the tilePlan
-check whether the strategy is "planes" or "waves
-locate the position of the sample
-for "planes" a spatial easing function applies
-for "waves" a temporal wave function applies
    -each cross section has a unique offset
-for each of app.crossSectionCount sample pixels
-for each sample, write pixels to destination canvas
    -with rotate transform if applicable
        -i.e. if sampleMode != outputMode
    -with scale transform if applicable
        -i.e. if optimizing for quantity 
-if the frame is the last frame in the tile
    -encode the cross ections in the tile
        as frames in a new video
    -release the canvasses back to the pool


 */


// We should probably only deal with a few tiles at a time 
// once a tile is complete, (e.g. encoding is finished)
// we can re-use the canvasses for the next tile.

const processVideo = async () => {

    const app = useAppStore()  // Pinia store

    // when processing, we will bake the current tilePlan
    // so that it doesnt mutate unexpectedly during processing
    const { tilePlan } = useTilePlan()
    app.set('tilePlan', tilePlan.value) // I'm not sure if this is actually preventing mutations
    console.log('tilePlan', app.tilePlan)

    // Initialize a canvas pool with adequate canvasses
    // Note: the pool becomes most useful as a way to conserve memory
    // when we have more than 3 tiles 
    let basePoolSize = app.crossSectionCount * 3;


    let maxPoolSize = app.crossSectionCount * app.tilePlan.tiles.length;
    const poolSize = Math.min(basePoolSize, maxPoolSize);
    app.set('canvasPool', createCanvasPool(poolSize, app.tilePlan.width, app.tilePlan.height));

    // go to the processing tab.
    app.set('currentTab', '2')
    // reset frame counter for a new file
    app.set('frameNumber', 0)
    app.set('readerIsFinished', false)


    try {

        // We will assume that the video is already loaded,
        // the following functions have already run in metaDataExtractor.js
        // webDemuxer.load 
        // webDemuxer.getAVStream 
        // webDemuxer.getVideoDecoderConfig

        if (VideoDecoder.isConfigSupported(app.config)) {
            app.log(`Codec ${app.config.codec} is Supported`)
            console.log(`Codec ${app.config.codec} is supported`);

            videoDecoder.configure({
                codec: app.config.codec,
                width: app.config.codedWidth,
                height: app.config.codedHeight,
                description: app.config.description,
                hardwareAcceleration: 'prefer-hardware', // default is 'prefer-hardware'
                latencyMode: 'quality'  // default is 'quality', see also: realtime.
            });

            // Read and decode video packets
            const stream = demuxer.readAVPacket(0, 0, 0, -1)

            // we could send the stream to a worker for decoding
            // instead of decoding it here.
            // the worker would send videoFrames back here
            // and we can forward them to the processFrame function
            // the worker would need to get the reader from the stream
            // and decode packets in the same way as here.


            const reader = stream.getReader()
            // pass along ReadableStreamDefaultReader for decoding
            await decodePackets(reader);

            app.log(`Decoded ${app.frameNumber} of ${app.frameCount} frames.`);

            if (app.frameNumber !== app.frameCount) {
                // app.frameNumnber is 0  for some reason on vp8
                // console.log('app.frameNumber, app.frameCount', app.frameNumber, app.frameCount)
                app.log(`Framecount mismatch.`)
            }

            app.log(`Done.`)
        }
        else {
            app.log(`Codec ${app.config.codec} is Not Supported`)
            console.error(`Codec ${app.config.codec} is not supported`);
        }

    } catch (error) {
        console.error('Failed to process file:', error);
    }
}

export { processVideo }

================
File: src/modules/webDemuxer.js
================
import { WebDemuxer } from "web-demuxer"

// Setup WebDemuxer
// NOTE: this assumes that vite.config.mjs is configured
// to copy wasm files from node_modules/web-demuxer/dist/wasm-files/*
// into a public ./wasm-files folder during the build process
const demuxer = new WebDemuxer({
    wasmLoaderPath: `${window.location.href}wasm-files/ffmpeg.js`
});

export { demuxer };

================
File: src/stores/appStore.js
================
import { defineStore } from 'pinia';

// This store keeps track of the global status of the application
export const useAppStore = defineStore('appStore', {
    state: () => ({
        config: {},
        frameCount: 0,
        frameNumber: 0,
        useShortSide: true,
        crossSectionCount: 60,
        crossSectionType: 'plane', // plane, wave
        samplingMode: 'rows',       // rows, columns
        outputMode: 'rows',         // rows, columns
        tileMode: 'tile',           // tile, full
        tileProportion: 'square',       // square, landscape, portrait
        prioritize: 'quantity',         // quantity, quality
        readerIsFinished: false,
        fileInfo: null,
        samplePixelCount: 0, /** equals width or height depending on samplingMode */
        messages: [],
        status: {},
        pauseDecode: null,
        resumeDecode: null,
        blob: null,
        blobURL: null,
        fpsNow: 0,
        lastFPSUpdate: 0,
        timestamps: [],
        currentTab: '0',
        // Canvasses are
        // -provided by canvasPool
        // -populated with samples
        // -encoded into animations
        canvasses: {},
        tilePlan: {},
        blobs: {},
        // New properties for synchronization
        currentPlaybackTime: 0,
        isPlaying: false,
    }),
    actions: {
        set(key, value) {
            this[key] = value;
        },
        log(message) {
            this.messages.push(message);
        },
        allocateCanvas(tileNumber, canvas) {
            // initialize an array if needed for this particualr tileNumber
            this.canvasses[tileNumber] = this.canvasses[tileNumber] || [];
            this.canvasses[tileNumber].push(canvas);
        },
        createBlob(tileNumber, blob) {
            // Initialize the blob for the given tileNumber
            this.blobs[tileNumber] = blob;
        },
        setStatus(key, value) {
            this.status[key] = value;
        },
        initializeDecodeControl() {
            this.pauseDecode = new Promise(resolve => {
                this.resumeDecode = resolve;
            });
        },
        async pauseIfNeeded() {
            if (this.pauseDecode) {
                await this.pauseDecode;
            }
        },
        resumeDecoding() {
            if (this.resumeDecode) {
                // Resolve the promise to continue the process
                this.resumeDecode();
                // Reinitialize pause and resume promises
                this.initializeDecodeControl();
            }
        },
        // Playback control
        updatePlaybackState({ currentTime, playing }) {
            this.currentPlaybackTime = currentTime;
            this.isPlaying = playing;
        }
    },
    getters: {
        fps() {
            const now = performance.now();
            this.timestamps.push(now);
            if (this.timestamps.length > 150) this.timestamps.shift();
            if (now - this.lastFPSUpdate > 250) {
                this.lastFPSUpdate = now;
                if (this.timestamps.length > 1) {
                    const timeSpan = (this.timestamps[this.timestamps.length - 1] - this.timestamps[0]) / 1000;
                    this.fpsNow = (this.timestamps.length - 1) / timeSpan;
                }
            }
            return parseInt(this.fpsNow);
        }
    }
});

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,mjs,ts,jsx,tsx}",
  ],
  theme: {},
  plugins: [],
}

================
File: vite.config.mjs
================
// vite.config.mjs
import { defineConfig } from 'vite';
import { viteStaticCopy } from 'vite-plugin-static-copy';
import vueDevTools from 'vite-plugin-vue-devtools'
import vue from '@vitejs/plugin-vue';


export default defineConfig({
    plugins: [
        vue(),
        vueDevTools(),
        viteStaticCopy({
            targets: [
                {
                    src: 'node_modules/web-demuxer/dist/wasm-files/*',
                    dest: 'wasm-files'
                }
            ]
        })
    ]
});
